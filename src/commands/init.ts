import fs from 'fs';
import path from 'path';
import { simpleGit } from 'simple-git';
import chalk from 'chalk';
import ora from 'ora';

export const initCommand = async (projectPath: string = process.cwd()): Promise<void> => {
    const spinner = ora('Initializing Chakravarti project...').start();

    try {
        // 1. Check/Initialize Git
        const git = simpleGit(projectPath);
        const isRepo = await git.checkIsRepo();

        if (!isRepo) {
            spinner.text = 'Initializing git repository...';
            await git.init();
            spinner.succeed('Git repository initialized');
        } else {
            spinner.info('Git repository already exists');
        }

        // 2. Create .chakravarti directory structure
        spinner.start('Creating .chakravarti directory structure...');
        const chakravartiDir = path.join(projectPath, '.chakravarti');
        const sprintsDir = path.join(chakravartiDir, 'sprints');
        const logsDir = path.join(chakravartiDir, 'logs');

        fs.mkdirSync(chakravartiDir, { recursive: true });
        fs.mkdirSync(sprintsDir, { recursive: true });
        fs.mkdirSync(logsDir, { recursive: true });

        spinner.succeed('Created .chakravarti directory structure');

        // 3. Generate agent-pool.yaml
        // 3. (Skipped) agent-pool.yaml is created by ckrv setup
        // spinner.start('Generating agent-pool.yaml...');

        // 4. Create initial sprint template
        // (Skipped) Sprints are now managed by `ckrv sprint` command
        // const sprintTemplatePath = path.join(__dirname, '../templates/sprint.md');

        // 5. Generate prompt templates
        spinner.start('Generating prompt templates...');
        const promptsDir = path.join(chakravartiDir, 'prompts');
        fs.mkdirSync(promptsDir, { recursive: true });

        const promptTemplates = ['planner', 'executor', 'tester'];
        for (const role of promptTemplates) {
            const templatePath = path.join(__dirname, `../templates/prompt-${role}.md`);
            const targetPath = path.join(promptsDir, `${role}.md`);

            if (fs.existsSync(templatePath)) {
                const template = fs.readFileSync(templatePath, 'utf8');
                fs.writeFileSync(targetPath, template);
            }
        }
        spinner.succeed('Created prompt templates');

        // 6. Copy Gemini CLI custom commands
        spinner.start('Installing Gemini CLI custom commands...');
        const geminiCommandsDir = path.join(projectPath, '.gemini', 'commands');
        fs.mkdirSync(geminiCommandsDir, { recursive: true });

        const ckrvCommandsDir = path.join(geminiCommandsDir, 'ckrv');
        fs.mkdirSync(ckrvCommandsDir, { recursive: true });

        const commandFiles = ['plan.toml', 'status.toml', 'task.toml', 'review.toml'];
        commandFiles.forEach(file => {
            const src = path.join(__dirname, '../templates/gemini-commands/ckrv', file);
            const dest = path.join(ckrvCommandsDir, file);
            if (fs.existsSync(src)) {
                fs.copyFileSync(src, dest);
            }
        });
        spinner.succeed('Installed Gemini CLI custom commands');

        // 7. Copy Makefile
        spinner.start('Creating Makefile...');
        const makefileSrc = path.join(__dirname, '../templates/Makefile');
        const makefileDest = path.join(projectPath, 'Makefile');
        if (!fs.existsSync(makefileDest) && fs.existsSync(makefileSrc)) {
            fs.copyFileSync(makefileSrc, makefileDest);
            spinner.succeed('Created Makefile');
        } else if (fs.existsSync(makefileDest)) {
            spinner.info('Makefile already exists');
        } else {
            spinner.warn('Makefile template not found');
        }

        // 8. Add entries to .gitignore
        const gitignorePath = path.join(projectPath, '.gitignore');
        const gitignoreEntries = [
            '.chakravarti/logs/',
            '.chakravarti/worktrees/',
            'GEMINI.md  # Auto-generated by ckrv chat',
        ];

        if (fs.existsSync(gitignorePath)) {
            const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');
            const entriesToAdd = gitignoreEntries.filter(entry =>
                !gitignoreContent.includes(entry.split('#')[0].trim())
            );
            if (entriesToAdd.length > 0) {
                fs.appendFileSync(gitignorePath, `\n# Chakravarti\n${entriesToAdd.join('\n')}\n`);
            }
        } else {
            fs.writeFileSync(gitignorePath, `# Chakravarti\n${gitignoreEntries.join('\n')}\n`);
        }

        // 9. Setup GitLab Project (if reachable)
        const { setupGitLabProject } = await import('../utils/gitlab');
        await setupGitLabProject(projectPath);

        console.log(chalk.green('\nâœ“ Chakravarti project initialized successfully!\n'));
        console.log(chalk.bold('Next steps:'));
        console.log(chalk.dim('  1. Run `ckrv setup` to configure your agent pool'));
        console.log(chalk.dim('  2. Customize .chakravarti/prompts/*.md to tailor agent instructions'));
        console.log(chalk.dim('  3. Edit .chakravarti/sprints/sprint-001.md to define your first tasks'));
        console.log(chalk.dim('  4. Run `ckrv up` to start the environment'));
        console.log(chalk.dim('  5. Run `ckrv run "your prompt"` to start working\n'));

    } catch (error) {
        spinner.fail('Failed to initialize project');
        console.error(error);
        throw error;
    }
};
