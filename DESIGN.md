# ðŸ“„ Chakravarti CLI â€” Design Document

**Version:** v0.1
**Status:** Draft for implementation
**Audience:** Humans + coding agents
**Primary Goal:** Enable deterministic, spec-driven, cost/time-optimized agentic code changes via a CLI, integrated with Git/GitLab workflows.

---

## 1. Problem Statement

Modern AI coding tools are:

* non-deterministic
* editor-centric
* unsafe for large codebases
* difficult to audit
* expensive and inefficient
* poorly integrated with CI/CD
* not enterprise-ready

We need a **local-first, spec-driven agent orchestration engine** that:

* executes code changes deterministically
* isolates risk via worktrees and containers
* optimizes for **cost and time**
* integrates with existing Git workflows (GitLab/GitHub)
* requires **no UI**
* supports **BYOK models**
* stores **no user code by default**

---

## 2. Non-Goals (Explicit)

Chakravarti CLI will NOT:

* be an IDE or editor
* provide a Kanban or chat UI
* host user code
* train or fine-tune models by default
* replace developers
* make autonomous production merges
* depend on proprietary cloud services

---

## 3. Core Value Proposition

> **Chakravarti is a CLI-based agent orchestration engine that converts specifications into verified, auditable code diffs using isolated execution and cost/time-optimized model routing.**

Key differentiators:

* Spec-first, not prompt-first
* Planner / Executor separation
* Multi-agent, multi-worktree execution
* Container-isolated runs
* Cost & time as first-class metrics
* BYOK, on-prem friendly
* Git-native outputs (diffs, branches, MRs)

---

## 4. Mental Model

Think of Chakravarti as:

```
Terraform / Bazel / CI engine
+
LLM planner + executors
+
Git worktrees
+
Containers
```

**Input:** Spec
**Output:** Verified git diff / branch / MR

---

## 5. Core Primitives (Must Exist)

### 5.1 Spec

* Source of truth
* Human-written, machine-readable
* Stored in repo (`/specs/*.md` or `.yaml`)

Example:

```yaml
id: add_rate_limiter
goal: Add rate limiting to login endpoint
constraints:
  - No breaking API changes
  - Must include unit tests
acceptance:
  - 429 returned after 5 attempts/min
```

---

### 5.2 Plan

* Generated by a **planner model**
* Deterministic DAG of steps

Example:

```yaml
steps:
  - analyze_login_flow
  - add_rate_limit_middleware
  - update_config
  - add_tests
  - run_tests
```

---

### 5.3 Worktree

* Each attempt runs in a **separate git worktree**
* No agent ever touches main branch

Path pattern:

```
.worktrees/<job_id>/<attempt_id>/
```

---

### 5.4 Executor

* Executes plan steps
* Uses cheaper models
* Allowed tools are explicitly defined

---

### 5.5 Verifier

* Runs tests
* Checks spec acceptance criteria
* Produces pass/fail + logs

---

### 5.6 Orchestrator

* Coordinates planner, executors, verifiers
* Handles retries
* Tracks cost & time
* Selects models dynamically

---

## 6. Execution Lifecycle

```
spec
 â†“
plan (planner model)
 â†“
attempt N:
   worktree
   â†“
   executor steps
   â†“
   verifier
   â†“
   success? â†’ produce diff
   failure? â†’ retry or replan
```

Outputs:

* git diff
* test results
* cost report
* time report

---

## 7. CLI Surface (MVP)

### 7.1 Init

```bash
ckrv init
```

Creates:

```
.specs/
.chakravarti/
```

---

### 7.2 Create Spec

```bash
ckrv spec new add_rate_limiter
```

---

### 7.3 Run Job

```bash
ckrv run specs/add_rate_limiter.yaml
```

Flags:

```bash
--optimize=cost|time|balanced
--max-attempts=3
--planner-model=gpt-4.1
--executor-model=gpt-4o-mini
```

---

### 7.4 Inspect Results

```bash
ckrv status <job_id>
ckrv diff <job_id>
ckrv report <job_id>
```

---

### 7.5 Promote Result

```bash
ckrv promote <job_id> --branch add-rate-limiter
```

---

## 8. Model Strategy (Critical)

### Planner

* Heavy, reasoning-strong model
* Used **once or few times**

### Executor

* Lightweight, cheap model
* Used many times

### Verifier

* No LLM if possible
* Uses tests + static checks

### Routing Logic

* Model choice based on:

  * step type
  * retry count
  * historical success metadata

---

## 9. Cost & Time Accounting

For every job:

* total wall-clock time
* per-step latency
* token usage per model
* estimated dollar cost

Stored locally:

```
.chakravarti/runs/<job_id>/metrics.json
```

---

## 10. Telemetry Policy (Default)

**Default:**

* NO code
* NO prompts
* NO diffs
* NO specs
* NO model outputs

Optional (opt-in):

* anonymous performance metadata
* benchmark results

---

## 11. Git & GitLab Integration

Chakravarti:

* produces branches
* produces diffs
* optionally opens MRs via GitLab API
* runs naturally inside GitLab CI

**GitLab is the UI.**

---

## 12. Security Model

* All execution is local or on-prem
* Containers isolate filesystem + network
* Tool allow-list enforced
* No hidden network calls
* Secrets injected via env only

---

## 13. MVP Scope (Strict)

Must ship:

* Spec â†’ Plan â†’ Execute â†’ Verify â†’ Diff
* Single repo
* Local execution
* One planner, one executor
* Git worktrees
* Cost/time metrics

Not in MVP:

* UI
* SaaS
* Dashboards
* Multi-repo
* Enterprise auth
* Marketplace
* Fine-tuning

---

## 14. Future Roadmap (Non-Blocking)

* Multi-agent parallel attempts
* CI pipeline mode
* Enterprise governance layer
* Optional cloud services
* Exclusive enterprise fine-tunes
* Spec generator service
* Agent marketplace

---

## 15. Success Criteria (MVP)

* Solves SWE-bench tasks
* Cheaper than single-model agents
* Faster convergence
* Deterministic reruns
* Zero data leakage
* Works fully offline (except model APIs)

---

## 16. Guiding Principle (For Agents)

> **Prefer determinism over creativity.
> Prefer isolation over speed.
> Prefer specs over prompts.
> Prefer diffs over chat.
> Prefer Git over UI.**

---

## 17. Instruction for Coding Agent

> Implement the smallest working system that satisfies this document.
> Do not add UI.
> Do not add cloud dependencies.
> Do not store user data.
> Make everything observable, reproducible, and auditable.

---